#include "3dmath.h"

#include <math.h>// * Нахождение нормали полигона *
// Чтобы найти нормаль полигона, нам нужно найти результат cross-a от двух
// векторов этого полигона. В общем, это всё, что нам нужно для получения направлений
// двух сторон треугольника. В конце концов, вектор — это только направление и длинна.
// Длинна вектора в нашем случае не важна. Нам нужно только узнать направление.
// Итак, имея 2 вектора треугольника, мы можем найти вектор, стоящий перпендикулярно
// к полигону.
// Теперь, в зависимости от порядка следования вершин, нормаль будет расположена с
// какой-то из сторон полигона. Вам остаётся только решить, в каком порядке отрисовывать
// вершины — ВСЕГДА запоминайте это.
// Обычно полигоны отрисовываются только с одной стороны. Никому не нужно второй раз
// отрисовывать сторону, которую не видно. Задумайтесь, если у вас есть какая-нибуть 3д
// модель, нужно ли вам отрисовывать внутренние стороны её полигонов? Конечно нет,
// это безсмысленно.
//

/////////////////////////////////////// CROSS \\\\\*
/////
/////   Возвращает вектор, перпендикулярный 2м переданным.
/////
/////////////////////////////////////// CROSS \\\\\*

CVector3 Cross(CVector3 vVector1, CVector3 vVector2)
{
	CVector3 vNormal;                       // результирующий вектор

	// Еще раз, если у нас есть 2 вектора (2 стороны полигона), у нас есть плоскость.
	// cross находит вектор, перпендикулярный плоскости, составляемой 2мя векторами.
	// Формула в принципе проста, но сложна для запоминания:

	// Значение X для векторы вычисляется так:  (V1.y * V2.z) — (V1.z * V2.y)
	vNormal.x = ((vVector1.y * vVector2.z) -(vVector1.z * vVector2.y));

	// Значение Y для векторы вычисляется так:  (V1.z * V2.x) — (V1.x * V2.z)
	vNormal.y = ((vVector1.z * vVector2.x) -(vVector1.x * vVector2.z));

	// Значение Z для векторы вычисляется так:  (V1.x * V2.y) — (V1.y * V2.x)
	vNormal.z = ((vVector1.x * vVector2.y) -(vVector1.y * vVector2.x));

	return vNormal;  // Возвращаем результат (направление, куда направлен полигон — нормаль)
}

/////////////////////////////////////// VECTOR \\\\\*
/////
/////   Возвращает вектор между 2мя точками.
/////
/////////////////////////////////////// VECTOR \\\\\*

CVector3 Vector(CVector3 vPoint1, CVector3 vPoint2)
{
	CVector3 vVector = { 0 };

	// Чтобы получить вектор между 2 точками (направление), нужно вычесть вторую
	// точку из первой.

	vVector.x = vPoint1.x - vPoint2.x;
	vVector.y = vPoint1.y - vPoint2.y;
	vVector.z = vPoint1.z - vPoint2.z;

	// Теперь возвращаем полученный результат

	return vVector;
}

/////////////////////////////////////// MAGNITUDE \\\\\*
/////
/////   возвращает величину нормали
/////
/////////////////////////////////////// MAGNITUDE \\\\\*

float Magnitude(CVector3 vNormal)
{
	return (float)sqrt((vNormal.x * vNormal.x) +
		(vNormal.y * vNormal.y) +
		(vNormal.z * vNormal.z));
}

/////////////////////////////////////// NORMALIZE \\\\\*
/////
/////   возвращает нормализованный вектор (с длинной 1)
/////
/////////////////////////////////////// NORMALIZE \\\\\*

CVector3 Normalize(CVector3 vNormal)
{
	float magnitude = Magnitude(vNormal);

	vNormal.x /= magnitude;
	vNormal.y /= magnitude;
	vNormal.z /= magnitude;

	return vNormal;
}

/////////////////////////////////////// NORMAL \\\\\*
/////
/////   Возвращает нормаль полигона
/////
/////////////////////////////////////// NORMAL \\\\\*

CVector3 Normal(CVector3 vTriangle[])
{
	CVector3 vVector1 = Vector(vTriangle[2], vTriangle[0]);
	CVector3 vVector2 = Vector(vTriangle[1], vTriangle[0]);

	// В функцию передаются три вектора — треугольник. Мы получаем vVector1 и vVector2 — его
	// стороны. Теперь, имея 2 стороны треугольника, мы можем получить из них cross().
	// (*ЗАМЕЧАНИЕ*) Важно: первым вектором мы передаём низ треугольника, а вторым — левую
	// сторону. Если мы поменяем их местами, нормаль будет повернута в противоположную
	// сторону. В нашем случае мы приняли решение всегда работать против часовой.

	CVector3 vNormal = Cross(vVector1, vVector2);

	// Теперь, имея направление нормали, осталось сделать последнюю вещь. Сейчас её
	// длинна неизвестна, она может быть очень длинной. Мы сделаем её равной 1, это
	// называется нормализация. Чтобы сделать это, мы делим нормаль на её длинну.
	// Ну а как найти длинну? Мы используем эту формулу: magnitude = sqrt(x^2 + y^2 + z^2)

	vNormal = Normalize(vNormal);

	// Теперь вернём «нормализованную нормаль» =)
	// (*ПРИМЕЧАНИЕ*) если вы хотите увидеть, как работает нормализация, закомментируйте
	// предидущую линию. Вы увидите, как длинна нормаль до нормалицации. Я стого рекомендую
	// всегда использовать эту функцию. И запомните, неважно, какова длинна нормали
	// (конечно, кроме (0,0,0)), если мы её нормализуем, она всегда будет равна 1.

	return vNormal;
}